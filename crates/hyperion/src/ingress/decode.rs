#![expect(
    nonstandard_style,
    reason = "Most of this code is generated by macros. It is easier, simpler, and faster in \
              terms of compilation speed to use the packet and state names as-is from \
              for_each_state than it is to use the paste macro to convert them to the appropriate \
              casing"
)]

use bevy::{ecs::batching::BatchingStrategy, prelude::*};
use paste::paste;
use tracing::error;
use valence_protocol::Packet as _;

use crate::{
    net::{Compose, ConnectionId, PacketDecoder, decoder::BorrowedPacketFrame},
    simulation::{packet::Packet, packet_state},
};

mod __private {
    use std::{
        cell::RefCell,
        sync::atomic::{AtomicU64, Ordering},
    };

    use bevy::prelude::*;
    use thread_local::ThreadLocal;
    use tracing::warn;

    #[derive(Default, Resource)]
    pub struct PacketIdGenerator(AtomicU64);

    impl PacketIdGenerator {
        pub(crate) fn next(&self) -> u64 {
            let id = self.0.fetch_add(1, Ordering::Relaxed);
            if id == u64::MAX {
                warn!(
                    "c2s packet ids are wrapping around to 0, this may cause issues with packet \
                     ordering"
                );
            }
            id
        }
    }

    #[derive(Default, Resource)]
    pub struct Decompressor(pub ThreadLocal<RefCell<libdeflater::Decompressor>>);
}

mod buffers {
    use crate::simulation::packet;

    hyperion_packet_macros::for_each_state! {
        #{
            #for_each_packet! {
                #[derive(Default)]
                pub struct #state {
                    #{pub #packet_name: boxcar::Vec<packet::#state::#packet_name>,}
                }
            }
        }
    }
}

mod writers {
    use bevy::{ecs::system::SystemParam, prelude::*};

    use crate::simulation::packet;

    hyperion_packet_macros::for_each_state! {
        #{
            #for_each_packet! {
                #[derive(SystemParam)]
                pub struct #state<'w> {
                    #{pub #packet_name: EventWriter<'w, packet::#state::#packet_name>,}
                }
            }
        }
    }
}

/// Whether the protocol may transition to another state after a packet in one of these states are
/// sent
mod may_transition {
    pub const handshake: bool = true;
    pub const status: bool = false;
    pub const login: bool = true;
    pub const play: bool = false;
}

fn try_next_frame(
    compose: &Compose,
    connection_id: ConnectionId,
    decoder: &PacketDecoder,
    decompressor: &mut libdeflater::Decompressor,
    receiver: &mut packet_channel::Receiver,
) -> Option<BorrowedPacketFrame> {
    let raw_packet = receiver.try_recv()?;
    match decoder.try_next_packet(decompressor, raw_packet) {
        Ok(packet) => Some(packet),
        Err(e) => {
            error!("failed to decode packet: {e}");
            compose.io_buf().shutdown(connection_id);
            None
        }
    }
}

hyperion_packet_macros::for_each_state! {
    #{
        pub fn #state(
            mut query: Query<
            '_,
            '_,
            (
                Entity,
                &ConnectionId,
                &PacketDecoder,
                &mut packet_channel::Receiver,
            ),
            paste! { With<packet_state::[< #state:camel >]> }
            >,
            compose: Res<'_, Compose>,
            packet_id_generator: Res<'_, __private::PacketIdGenerator>,
            decompressor: Res<'_, __private::Decompressor>,
            mut writers: writers::#state<'_>,
        ) {
            let compose = &compose;
            let packet_id_generator = &packet_id_generator;
            let buffers = buffers::#state::default();

            // Fill buffers
            let scope = tracing::info_span!("fill_buffers").entered();
            query.par_iter_mut().batching_strategy(BatchingStrategy {
                batch_size_limits: 1..128,
                batches_per_thread: 1,
            }).for_each(|(sender, &connection_id, decoder, receiver)| {
                let receiver = receiver.into_inner();
                let mut decompressor = decompressor.0.get_or_default().borrow_mut();

                loop {
                    let Some(frame) = try_next_frame(
                        compose,
                        connection_id,
                        decoder,
                        &mut decompressor,
                        receiver,
                    ) else {
                        break;
                    };

                    let frame_id = frame.id;

                    #for_each_packet! {
                        let result: anyhow::Result<()> = match frame_id {
                            #{
                                #valence_packet::ID => {
                                    match frame.decode::<#static_valence_packet>() {
                                        Ok(data) => {
                                            buffers.#packet_name.push(Packet::new(
                                                sender,
                                                connection_id,
                                                packet_id_generator.next(),
                                                data
                                            ));
                                            Ok(())
                                        },
                                        Err(e) => Err(e)
                                    }
                                },
                            }
                            _ => {
                                Err(anyhow::Error::msg("invalid packet id"))
                            }
                        };
                    }

                    if let Err(e) = result {
                        // The call to error! is placed outside of the match statement to help reduce
                        // compile times by reducing code duplication from the expansion of the error!
                        // macro
                        error!("error while decoding packet (id: {frame_id}): {e}");
                        compose.io_buf().shutdown(connection_id);
                        break;
                    }

                    if may_transition::#state {
                        // The packet handler for this packet might change the player to
                        // another packet state, so more packets cannot be decoded at this
                        // moment
                        break;
                    }
                }
            });
            scope.exit();

            // Copy buffers to the EventWriters
            let scope = tracing::info_span!("write_events").entered();
            #for_each_packet! {
                #{
                    writers.#packet_name.write_batch(buffers.#packet_name);
                }
            }
            scope.exit();
        }
    }
}

pub struct DecodePlugin;

impl Plugin for DecodePlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(__private::PacketIdGenerator::default());
        app.insert_resource(__private::Decompressor::default());
        hyperion_packet_macros::for_each_state! {
            app.add_systems(
                FixedUpdate, (
                    #{
                        #state,
                    }
                )
            );
        }
    }
}
